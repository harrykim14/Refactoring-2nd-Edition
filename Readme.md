<!-- Heading -->

# 리팩터링 2판 스터디

<!-- Line -->

개인 프로젝트를 진행하며 **좋은 코드란 무엇인가**?에 대해 알아보고자 클린코드에 이어 리팩터링 2판을 구매하여 책의 예시를 따라가보고자 한다. (2021/01/03 시작)

## 목차
[Chapter 01](#chapter-01)
[Chapter 02](#chapter-02)
[Chapter 03](#chapter-03)
[Chapter 04](#chapter-04)
[Chapter 05](#chapter-05)
[Chapter 06](#chapter-06)
[Chapter 07](#chapter-07)
[Chapter 08](#chapter-08)

## Chapter 01
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/blob/master/Chapter01/01-3.%20logic%20wt%20class.js)
* 함수 추출하기 
    - 함수 및 변수는 명확한 이름으로 변경하기
    - 좋은 코드라면 하는 일이 명확히 드러나야하며 변수 이름은 커다란 역할을 함

* 조건부 로직을 다형성으로 바꾸기
    - 타입 코드 대신 서브클래스를 사용하도록 변경
    - 다형성을 이용하여 필요 할 때 오버라이드하게 만들기

> ### 챕터1에서 정리하는 리팩터링 작업의 단계
1. **반복문 쪼개기**로 누적 변수값을 분리
2. **문장 슬라이드하기**로 초기화 문장을 누적 코드 앞으로 옮김
3. **함수 추출하기**로 별도 함수로 추출
4. **변수 인라인하기**로 변수 제거


## Chapter 02
~코드 보기~ 예시 코드 없음
* **리팩터링** : 소프트웨어의 겉보기 동작은 그대로 유지한 채 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

> 리팩터링의 의미
* **특정한 방식**에 따라 코드를 정리하는 것
* 리팩터링하기 전과 후의 코드가 **똑같이 동작**해야 함
* 함수 추출하기를 거치면 콜스택이 달라져 성능이 변할 수도 있음
* 리팩터링의 목적은 **코드를 이해하고 수정하기 쉽게** 만드는 것

> 리팩터링은 언제 해야 할까?

**비슷한 일을 세 번째 하게 되면 리팩터링한다**

1. 구조를 바꾸면 다른 작업을 하기가 쉬워질 부분을 찾아 정리하기
2. 자잘한 세부 코드에 이해를 위한 리팩터링 하기 (변수명 변경 및 긴 함수 나누기 등)
3. 캠핑 규칙([*주1](#주석))에 따라 처음 봤을 때보다 깔끔하게 정리하기
4. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다
    * 소프트웨어 개발은 추가하는 과정만이 아니다
5. 코드 리뷰에 리팩터링을 활용하기
6. 자가 테스트 코드를 마련하면 리팩터링에 도움이 된다

> 리팩터링을 고려해야 할 때
* 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 두기
* 처음부터 새로 작성하는게 쉬울 때엔 리팩터링 하지 않기
* 리팩터링을 도덕적인 이유로 정당화하지 않기

> 리팩터링을 활용하기
1. 아키텍처를 결정하는 시간을 줄여 개발을 바로 시작하여 개발 중에 리팩터링으로 아키텍처를 다듬을 수 있다
2. 자가 테스트 코드와 리팩터링을 묶어 **테스트 주도 개발**(TDD)라 하며 요구사항 변화에 빠르게 대응하고 안정적인 구조를 코드베이스에 심을 수 있다
3. 리팩터링은 단기적으로 성능이 느려질 수도 있지만 튜닝하기 쉽게 만들기 때문에 결국 더 빠른 소프트웨어를 얻게 될 수 있다

# Chapter 03
~코드 보기~ 예시 코드 없음
> 리팩터링, 무엇을 해야 하는가?
* 좋은 **이름** 정하기: 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기 등
* 반복되는 코드 줄이기: 함수 추출하기, 문장 슬라이드하기, 메서드 올리기 등
* 함수는 **짧게** 작성하기
    * 함수 내 매개변수와 임시변수의 수를 줄이기
    * **조건문 분해하기**로 switch문 내 case 본문을 함수 호출문 하나로 바꾸기
    * **반복문 쪼개기**로 독립된 함수로 만들기
* 매개변수 목록 줄이기: 객체 통째로 넘기기, 여러 함수를 클래스로 묶기 등
* 전역 데이터에 주의하기: **변수 캡슐화하기**
* 데이터 변경에 주의하기
    * **변수 캡슐화**: 정해놓은 함수를 거쳐야만 값이 수정되게 하기
    * **변수 쪼개기**: 용도별로 독립변수에 저장하기
    * 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기
* 단일 책임 원칙 지키기: 단계 쪼개기, 함수 모으기 등
* 모듈 내 상호작용은 늘리고 모듈 간 상호작용은 최소화하기
* 데이터 뭉치를 찾기: **클래스**를 적극적으로 사용하기
* 기본형 데이터를 객체로 바꾸기
* 중복되는 switch문 제거하기
* 반복문은 파이프라인으로 변경하기([*주2](#주석))
* **나중에 필요할 것 같은 코드** 제거하기
* 임시 필드(쓰이지 않는 것 처럼 보이는 필드)에 주의하기
* 메시지 체인([*주3](#주석))에 주의하기
* 접두어나 접미어가 같은 필드들을 클래스로 추출하기
* 서브클래스가 인터페이스를 따르지 않는지 주의하기
* **주석이 필요하다 느끼면 주석이 필요없는 코드로 리팩터링 해본다**

# Chapter 04
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/blob/master/Chapter04/Province.js)
> 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다
* 모카를 사용하여 테스트 코드를 작성(예시)
```
describe('province', function() {
    it('shortfall', function() {
        const asia = new Province(sampleProvinceData());
        expect(asia.shortfall).equal(5);
    })
})
```
> 자주 테스트하고 적어도 하루에 한 번은 전체 테스트를 돌려보자

> 문제가 생길 가능성이 있는 경계조건을 생각해보고 그 부분을 집중적으로 테스트하자 

> **위험한 기능에 집중하여 테스트 코드를 작성하기**

> 모든 버그를 잡아낼 수 없다는 생각으로 테스트를 작성하지 않는다면 대다수의 버그를 잡을 수 있는 기회를 날리는 셈이다.

# Chapter 05

* 책 내에서 소개하는  리팩터링 형식 안내

# Chapter 06
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/tree/master/Chapter06)(Chapter 06 폴더 내 리팩터링 방식별로 나눔)

> **함수 추출하기 절차**

1. 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다
2. 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다
3. 원본 함수에서 참조할 변수가 있거나 유효 범위 외 변수가 있는지 확인한다
4. 변수를 다 처리했다면 컴파일한다.
5. 추출한 부분을 해당 함수를 호출하도록 변경한다
6. 테스트한다
7. 비슷한 코드가 없는지 확인한다

> **함수 인라인하기 절차**
1. 다형 메서드인지 확인하기 (서브클래스에서 오버라이드하는 메서드는 인라인 하지 않기)
2. 인라인할 함수를 호출하는 곳을 모두 찾는다
3. 각 호출문을 함수 본문으로 교체한다
4. 하나씩 교체할 때마다 테스트한다
5. 원래 함수를 삭제한다

> **변수 추출하기 절차**
1. 추출하려는 표현식에 부작용은 없는지 확인한다
2. 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다
3. 원본 표현식을 새로 만든 변수로 교체한다
4. 테스트한다
5. 표현식을 여려곳에서 사용한다면 각각 새로 만든 변수로 교체

> **변수 인라인하기**

> **함수 선언 바꾸기**

> **변수 캡슐화하기**
```
let defaultOwner = { firstName : "Martin", lastName : "Fowler" }
```

##### ▼ 캡슐화로 데이터를 변경하고 사용하는 코드를 감시할 수 있게 하기

```
let defaultOwner = { firstName : "Martin", lastName : "Fowler" }
export function defaultOwner() { return defaultOwner; }
export function setDefaultOwner(arg) { defaultOwner = arg; } 

```
**변수 캡슐화하기 절차**
1. 변수로의 접근과 갱신을 전담하는 함수를 만든다
2. 정적 검사를 수행
3. 변수를 직접 참조하던 부분을 모두 캡슐화 함수 호출로 변경 및 테스트하기
4. 변수로의 접근 범위를 제한하기
5. 테스트하기
6. 변수값이 레코드라면 레코드 캡슐화하기를 적용할지 고려

> **변수 이름 바꾸기**

> **매개변수 객체 만들기 절차**
1. 적당한 데이터 구조를 새로 만들기 
    - 클래스로 만들면 나중에 동작까지 함께 묶기 좋음
2. 테스트한다
3. 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가
4. 테스트한다
5. 함수 호출 시 데이터 구조 인스턴스를 넘기도록 수정 및 테스트
6. 기존 매개변수를 사용하던 코드를 변경
7. 기존 매개변수를 제거하고 테스트

> **여러 함수를 클래스로 묶기 절차**
1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화
2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮기기
3. 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮기기

> **여러 함수를 변환 함수로 묶기 절차**
1. 변환할 레코드를 입력받아서 값을 그대로 반홚나느 변환 함수를 만들기
2. 묶을 함수 중 하나를 골라 본문 코드를 변환함수로 옮기고 처리 결과를 레코드에 새 필드로 기록하고 클라이언트 코드가 이 필드를 사용하도록 수정
3. 테스트하기
4. 나머지 함수도 위 과정을 반복하여 처리

> **단계 쪼개기 절차**
1. 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다
2. 테스트한다
3. 중간 데이터 구조를 만들어 앞에서 추출한 함수의 인수로 추가한다
4. 테스트한다
5. 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다
    * 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다
    * 옮길 때마다 테스트한다
6. 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 만들기

# Chapter 07
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/tree/master/Chapter07)

> **레코드 캡슐화하기 절차**
1. 레코드를 담은 변수를 캡슐화한다
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체
    * 클래스 내에 원본 레코드를 반환하는 접근자를 정의
    * 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정
3. 테스트한다
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 새 함수로 바꾼다
    * 필드에 접근할 때는 객체의 접근자를 사용하기
    * 한 부분을 바꿀 때 마다 테스트하기
    * 클라이언트가 데이터를 읽기만 하는지도 고려하기
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수를 제거한다
7. 테스트한다
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다

> **컬렉션 캡슐화하기 절차**
1. 컬렉션 캡슐화 전이라면 변수 캡슐화부터 한다
2. 컬렉션에 원소를 추가/제거하는 함수를 추가한다
    * 컬렉션을 통째로 바꾸는 setter는 제거한다
    * setter를 제거할 수 없을 때엔 인수로 받은 컬렉션을 복제해 저장하도록 한다
3. 테스트한다
4. 컬렉션을 참조하는 부분을 모두 찾는다
    * 컬렉션의 변경자를 호출하는 코드가 앞에서 추가한 추가/제거 함수를 호출하도록 수정한다
5. 컬렉션 getter를 수정해서 원본 내용을 수정할 수 없는 복제본을 반환하게 한다
6. 테스트한다

> **기본형을 객체로 바꾸기 절차**
1. 아직 변수를 캡슐화하지 않았다면 캡슐화한다
2. 단순한 값 클래스를 만들어 생성자는 기존 값을 인수로 받아 저장하고 이 값을 변환하는 getter를 추가한다
3. 테스트한다
4. 값 클래스의 인스턴스를 새로 만들어 필드에 저장하도록 setter를 수정
5. 새로 만든 클래스의 getter를 호출한 결과를 반환하도록 수정
6. 테스트한다
7. 함수 이름을 바꾸면 더 알아보기 쉬워지는지 고려

> **임시변수를 질의 함수로 바꾸기 절차**
1. 변수가 사용되기 전에 값이 확실히 결정되는지 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지는 않는지 확인한다
2. 읽기전용이 가능하면 일기전용으로 만들기
3. 테스트한다
4. 변수 대입문을 함수로 추출
5. 테스트한다
6. 변수 인라인하기로 임시 변수를 제거

> **클래스 추출하기 절차**
1. 클래스의 역할을 분리할 방법을 정한다
2. 분리될 역할을 담당할 클래스를 새로 만든다
3. 원래 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하여 필드에 저장해둔다
4. 분리될 역할에 필요한 필드들을 새 클래스로 옮긴다
    * 옮길때마다 테스트한다
5. 메서드들도 새 클래스로 옮긴다
    * 호출당하는 일이 많은 메서드부터 옮기면서 테스트한다
6. 양쪽 클래스의 인터페이스에서 불필요한 메서드를 제거한다
7. 새 클래스를 외부로 노출할지 정한다
    * 노출 시엔 새 클레스에 참조를 값으로 바꿀지 고려한다


> **클래스 인라인하기 절차**
1. 소스 클래스의 각 public 메서드에 대응하는 메서드들을 타깃 클래스에 생성
    * 이 메서드들은 단순히 작업을 소스 클래스로 위임해야 한다
2. 소스 클래스의 메서드를 사용하는 코드를 모두 타깃 클래스의 위임 메서드를 사용하도록 바꾸고 테스트한다
3. 소스 클래스의 메서드와 필드 모두 타깃 클래스로 옮기고 테스트한다
4. 소스 클래스를 삭제한다

> **위임 숨기기 절차**
1. 위임 객체의 각 메서드에 해당하는 위임 메서드를 서버에 생성한다
2. 클라이언트가 위임 객체 대신 서버를 호출하도록 수정하고 테스트한다
3. 모두 수정하면 서버로부터 위임 객체를 얻는 접근자를 제거한다
4. 테스트한다

> **중개자 제거하기 절차**
1. 위임 객체를 얻는 getter를 생성한다
2. 위임 메서드를 호출하는 클라이언트가 모두 이 getter를 거치도록 수정하고 테스트한다
3. 수정이 끝나면 위임 메서드를 삭제한다

> **알고리즘 교체하기 절차**
1. 교체할 코드를 함수 하나에 모으기
2. 이 함수만을 이용해 동작을 검증하는 테스트를 마련한다
3. 대체할 알고리즘을 준비
4. 테스트한다
5. 기존 알고리즘과 새 알고리즘의 결과를 비교하는 테스트를 수행한다
    * 두 결과가 같을 때 까지 새 알고리즘을 테스트하고 디버깅한다

## Chapter 08
[코드 보기](#)

> **함수 옮기기 절차**
1. 선택한 함수가 현재 컨텍스트에서 사용 중인 모든 요소를 살펴보고 함께 옮겨야 할 함수가 있는지 고려한다
    * 함께 옮겨야 할 함수가 있다면 대체로 그 함수를 먼저 옮기는 게 낫다
    * 하위 함수들의 호출자가 고수준 함수 하나뿐이라면 하위 함수들을 먼저 고수준 함수에 인라인한다
2. 선택한 함수가 다형 메서드인지 확인한다
3. 선택한 함수를 타깃 컨텍스트로 복사하고 타깃 함수를 다듬는다
    * 함수 본문에서 소스 컨텍스트의 요소를 사용한다면 매개변수로 넘겨주거나 소스 컨텍스트 자체를 참조로 넘긴다
4. 테스트한다
5. 소스 컨텍스트에서 타깃 함수를 참조하도록 한다
6. 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다
7. 테스트한다
8. 소스 함수를 인라인할지 고민해본다

> **필드 옮기기 절차**
1. 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다
2. 테스트한다
3. 타깃 객체에 필드와 접근자 메서드들을 생성한다
4. 테스트한다
5. 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다
6. 접근자들이 타깃 필드를 사용하도록 수정한다
7. 테스트한다
8. 소스 필드를 제거한다
9. 테스트한다

> **문장을 함수로 옮기기 절차**
1. 반복 코드가 함수 호출 부분과 멀리 떨어져 있다면 문장 슬라이드하기를 적용해 근처로 옮긴다
2. 타깃 함수를 호출하는 곳이 한 곳뿐이면 단순히 소스 위치에서 해당 코드를 잘라내어 피호출 함수로 복사하고 테스트한다
    * 이 경우라면 나머지 단계는 무시한다
3. 호출자가 둘 이상이면 호출자 중 하나에서 타깃 함수 호출 부분과 옮기려는 문장들을 다른 함수로 추출하고 임시 이름을 지어준다
4. 다른 호출자 모두 방금 추출한 함수를 사용하도록 수정한다
5. 모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인하고 원래 함수를 제거한다
6. 새로운 함수의 이름을 원래 함수 이름으로 변경한다

> **문장을 호출한 곳으로 옮기기 절차**
1. 호출자가 한두개뿐이고 피호출 함수도 간단하다면 피호출 함수의 처음줄을 잘라내서 호출자로 복사해넣는다
    * 테스트가 통과되면 여기서 마무리한다
2. 이동이 필요하지 않은 문장은 함수로 추출하고
3. 원래 함수를 인라인한다
4. 추출된 함수의 이름을 원래 함수의 이름으로 변경한다

> **인라인 코드를 함수 호출로 바꾸기**
* 함수는 여러 동작을 하나로 묶어주는 역할이지만 이미 존재하는 함수와 같은 일을 하는 함수가 더 있다면 해당 코드를 함수 호출로 대체하기

> **문장 슬라이드하기 절차**
1. 코드 조각의 원래 위치와 목표 위치 사이의 코드를 보고 조각을 모으면 동작이 달라질 코드가 있는지 본다
    * 코드 조각에서 참조하는 요소를 선언하는 문장 앞으로는 이동할 수 없다
    * 코드 조각을 참조하는 요소의 뒤로는 이동할 수 없다
    * 코드 조각에서 참조하는 요소를 수정하는 문장을 건너뛰어 이동할 수 없다 
    * 코드 조각이 수정하는 요소를 참조하는 요소를 건너뛰어 이동할 수 없다
2. 코드 조각을 잘라내어 목표 위치에 붙여넣는다
3. 테스트한다

> **반복문 쪼개기 절차**
1. 반복문을 복제해 두 개로 만든다
2. 반복문이 중복되어 생기는 부수효과를 파악해서 제거한다
3. 테스트한다
4. 각 반복문을 함수로 추출할지 고려한다

> **반복문을 파이프라인으로 바꾸기 절차**
1. 반복문에서 사용하는 컬렉션을 가리키는 변수를 만든다
2. 각 단위 행위를 적절한 파이프라인 연산[(*주2)](#주2)으로 대체하고 대체할 때마다 테스트한다
3. 반복문의 모든 동작을 대체했다면 반복문을 삭제한다

> **죽은 코드 제거하기**
* 더 이상 사용되지 않는 코드는 지운다
* 혹시 다시 필요해질것 같다면 버전 관리 시스템에 저장해놓은 버전을 불러와 적용한다

#### 주석
* [주1](#chapter-02) : 도착했을때보다 깔끔하게 정돈하고 떠난다(챕터1.7)
* [주2](#chapter-03) : ES6 문법에서 제공하는 filter, reduce, map 등을 활용하는 것
* [주3](#chapter-03) : 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
