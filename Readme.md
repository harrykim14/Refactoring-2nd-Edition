<!-- Heading -->

# 리팩터링 2판 스터디

<!-- Line -->

개인 프로젝트를 진행하며 **좋은 코드란 무엇인가**?에 대해 알아보고자 클린코드에 이어 리팩터링 2판을 구매하여 책의 예시를 따라가보고자 한다. (2021/01/03 시작)

## 목차
* [Chapter 01](#chapter-01): 리팩터링 첫 번째 예시
* [Chapter 02](#chapter-02): 리팩터링 원칙
* [Chapter 03](#chapter-03): 코드에서 나는 악취
* [Chapter 04](#chapter-04): 테스트 구축하기
* [Chapter 05](#chapter-05): 리팩터링 카탈로그 보는 법(생략)
* [Chapter 06](#chapter-06): 기본적인 리팩터링
* [Chapter 07](#chapter-07): 캡슐화
* [Chapter 08](#chapter-08): 기능 이동
* [Chapter 09](#chapter-09): 데이터 조직화
* [Chapter 10](#chapter-10): 조건부 로직 간소화


## Chapter 01
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/blob/master/Chapter01/01-3.%20logic%20wt%20class.js)

<details markdown="chapter-01">
<summary>챕터 내 자세한 내용 보기</summary>

* 함수 추출하기 
    - 함수 및 변수는 명확한 이름으로 변경하기
    - 좋은 코드라면 하는 일이 명확히 드러나야하며 변수 이름은 커다란 역할을 함

* 조건부 로직을 다형성으로 바꾸기
    - 타입 코드 대신 서브클래스를 사용하도록 변경
    - 다형성을 이용하여 필요 할 때 오버라이드하게 만들기

> ### 챕터1에서 정리하는 리팩터링 작업의 단계
1. **반복문 쪼개기**로 누적 변수값을 분리
2. **문장 슬라이드하기**로 초기화 문장을 누적 코드 앞으로 옮김
3. **함수 추출하기**로 별도 함수로 추출
4. **변수 인라인하기**로 변수 제거

</details>

## Chapter 02
예시 코드 없음

<details markdown="chapter-02">
<summary>챕터 내 자세한 내용 보기</summary>

* **리팩터링** : 소프트웨어의 겉보기 동작은 그대로 유지한 채 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

> 리팩터링의 의미
* **특정한 방식**에 따라 코드를 정리하는 것
* 리팩터링하기 전과 후의 코드가 **똑같이 동작**해야 함
* 함수 추출하기를 거치면 콜스택이 달라져 성능이 변할 수도 있음
* 리팩터링의 목적은 **코드를 이해하고 수정하기 쉽게** 만드는 것

> 리팩터링은 언제 해야 할까?

**비슷한 일을 세 번째 하게 되면 리팩터링한다**

1. 구조를 바꾸면 다른 작업을 하기가 쉬워질 부분을 찾아 정리하기
2. 자잘한 세부 코드에 이해를 위한 리팩터링 하기 (변수명 변경 및 긴 함수 나누기 등)
3. 캠핑 규칙([*주1](#주석))에 따라 처음 봤을 때보다 깔끔하게 정리하기
4. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다
    * 소프트웨어 개발은 추가하는 과정만이 아니다
5. 코드 리뷰에 리팩터링을 활용하기
6. 자가 테스트 코드를 마련하면 리팩터링에 도움이 된다

> 리팩터링을 고려해야 할 때
* 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 두기
* 처음부터 새로 작성하는게 쉬울 때엔 리팩터링 하지 않기
* 리팩터링을 도덕적인 이유로 정당화하지 않기

> 리팩터링을 활용하기
1. 아키텍처를 결정하는 시간을 줄여 개발을 바로 시작하여 개발 중에 리팩터링으로 아키텍처를 다듬을 수 있다
2. 자가 테스트 코드와 리팩터링을 묶어 **테스트 주도 개발**(TDD)라 하며 요구사항 변화에 빠르게 대응하고 안정적인 구조를 코드베이스에 심을 수 있다
3. 리팩터링은 단기적으로 성능이 느려질 수도 있지만 튜닝하기 쉽게 만들기 때문에 결국 더 빠른 소프트웨어를 얻게 될 수 있다

</details>

## Chapter 03
예시 코드 없음

<details markdown="chapter-03">
<summary>챕터 내 자세한 내용 보기</summary>

> 리팩터링, 무엇을 해야 하는가?
* 좋은 **이름** 정하기: 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기 등
* 반복되는 코드 줄이기: 함수 추출하기, 문장 슬라이드하기, 메서드 올리기 등
* 함수는 **짧게** 작성하기
    * 함수 내 매개변수와 임시변수의 수를 줄이기
    * **조건문 분해하기**로 switch문 내 case 본문을 함수 호출문 하나로 바꾸기
    * **반복문 쪼개기**로 독립된 함수로 만들기
* 매개변수 목록 줄이기: 객체 통째로 넘기기, 여러 함수를 클래스로 묶기 등
* 전역 데이터에 주의하기: **변수 캡슐화하기**
* 데이터 변경에 주의하기
    * **변수 캡슐화**: 정해놓은 함수를 거쳐야만 값이 수정되게 하기
    * **변수 쪼개기**: 용도별로 독립변수에 저장하기
    * 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기
* 단일 책임 원칙 지키기: 단계 쪼개기, 함수 모으기 등
* 모듈 내 상호작용은 늘리고 모듈 간 상호작용은 최소화하기
* 데이터 뭉치를 찾기: **클래스**를 적극적으로 사용하기
* 기본형 데이터를 객체로 바꾸기
* 중복되는 switch문 제거하기
* 반복문은 파이프라인으로 변경하기([*주2](#주석))
* **나중에 필요할 것 같은 코드** 제거하기
* 임시 필드(쓰이지 않는 것 처럼 보이는 필드)에 주의하기
* 메시지 체인([*주3](#주석))에 주의하기
* 접두어나 접미어가 같은 필드들을 클래스로 추출하기
* 서브클래스가 인터페이스를 따르지 않는지 주의하기
* **주석이 필요하다 느끼면 주석이 필요없는 코드로 리팩터링 해본다**

</details>

## Chapter 04
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/blob/master/Chapter04/Province.js)

<details markdown="chapter-04">
<summary>챕터 내 자세한 내용 보기</summary>

> 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다
* 모카를 사용하여 테스트 코드를 작성(예시)
```
describe('province', function() {
    it('shortfall', function() {
        const asia = new Province(sampleProvinceData());
        expect(asia.shortfall).equal(5);
    })
})
```
> 자주 테스트하고 적어도 하루에 한 번은 전체 테스트를 돌려보자

> 문제가 생길 가능성이 있는 경계조건을 생각해보고 그 부분을 집중적으로 테스트하자 

> **위험한 기능에 집중하여 테스트 코드를 작성하기**

> 모든 버그를 잡아낼 수 없다는 생각으로 테스트를 작성하지 않는다면 대다수의 버그를 잡을 수 있는 기회를 날리는 셈이다.

</details>

## Chapter 05

* 책 내에서 소개하는  리팩터링 형식 안내

## Chapter 06
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/tree/master/Chapter06)

<details markdown="chapter-06">
<summary>챕터 내 자세한 내용 보기</summary>

> **함수 추출하기 절차**

1. 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다
2. 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다
3. 원본 함수에서 참조할 변수가 있거나 유효 범위 외 변수가 있는지 확인한다
4. 변수를 다 처리했다면 컴파일한다.
5. 추출한 부분을 해당 함수를 호출하도록 변경한다
6. 테스트한다
7. 비슷한 코드가 없는지 확인한다

> **함수 인라인하기 절차**
1. 다형 메서드인지 확인하기 (서브클래스에서 오버라이드하는 메서드는 인라인 하지 않기)
2. 인라인할 함수를 호출하는 곳을 모두 찾는다
3. 각 호출문을 함수 본문으로 교체한다
4. 하나씩 교체할 때마다 테스트한다
5. 원래 함수를 삭제한다

> **변수 추출하기 절차**
1. 추출하려는 표현식에 부작용은 없는지 확인한다
2. 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다
3. 원본 표현식을 새로 만든 변수로 교체한다
4. 테스트한다
5. 표현식을 여려곳에서 사용한다면 각각 새로 만든 변수로 교체

> **변수 인라인하기**

> **함수 선언 바꾸기**

> **변수 캡슐화하기**
```
let defaultOwner = { firstName : "Martin", lastName : "Fowler" }
```

##### ▼ 캡슐화로 데이터를 변경하고 사용하는 코드를 감시할 수 있게 하기

```
let defaultOwner = { firstName : "Martin", lastName : "Fowler" }
export function defaultOwner() { return defaultOwner; }
export function setDefaultOwner(arg) { defaultOwner = arg; } 

```
**변수 캡슐화하기 절차**
1. 변수로의 접근과 갱신을 전담하는 함수를 만든다
2. 정적 검사를 수행
3. 변수를 직접 참조하던 부분을 모두 캡슐화 함수 호출로 변경 및 테스트하기
4. 변수로의 접근 범위를 제한하기
5. 테스트하기
6. 변수값이 레코드라면 레코드 캡슐화하기를 적용할지 고려

> **변수 이름 바꾸기**

> **매개변수 객체 만들기 절차**
1. 적당한 데이터 구조를 새로 만들기 
    - 클래스로 만들면 나중에 동작까지 함께 묶기 좋음
2. 테스트한다
3. 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가
4. 테스트한다
5. 함수 호출 시 데이터 구조 인스턴스를 넘기도록 수정 및 테스트
6. 기존 매개변수를 사용하던 코드를 변경
7. 기존 매개변수를 제거하고 테스트

> **여러 함수를 클래스로 묶기 절차**
1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화
2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮기기
3. 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮기기

> **여러 함수를 변환 함수로 묶기 절차**
1. 변환할 레코드를 입력받아서 값을 그대로 반홚나느 변환 함수를 만들기
2. 묶을 함수 중 하나를 골라 본문 코드를 변환함수로 옮기고 처리 결과를 레코드에 새 필드로 기록하고 클라이언트 코드가 이 필드를 사용하도록 수정
3. 테스트하기
4. 나머지 함수도 위 과정을 반복하여 처리

> **단계 쪼개기 절차**
1. 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다
2. 테스트한다
3. 중간 데이터 구조를 만들어 앞에서 추출한 함수의 인수로 추가한다
4. 테스트한다
5. 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다
    * 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다
    * 옮길 때마다 테스트한다
6. 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 만들기

</details>

## Chapter 07
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/tree/master/Chapter07)

<details markdown="chapter-07">
<summary>챕터 내 자세한 내용 보기</summary>

> **레코드 캡슐화하기 절차**
1. 레코드를 담은 변수를 캡슐화한다
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체
    * 클래스 내에 원본 레코드를 반환하는 접근자를 정의
    * 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정
3. 테스트한다
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 새 함수로 바꾼다
    * 필드에 접근할 때는 객체의 접근자를 사용하기
    * 한 부분을 바꿀 때 마다 테스트하기
    * 클라이언트가 데이터를 읽기만 하는지도 고려하기
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수를 제거한다
7. 테스트한다
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다

> **컬렉션 캡슐화하기 절차**
1. 컬렉션 캡슐화 전이라면 변수 캡슐화부터 한다
2. 컬렉션에 원소를 추가/제거하는 함수를 추가한다
    * 컬렉션을 통째로 바꾸는 setter는 제거한다
    * setter를 제거할 수 없을 때엔 인수로 받은 컬렉션을 복제해 저장하도록 한다
3. 테스트한다
4. 컬렉션을 참조하는 부분을 모두 찾는다
    * 컬렉션의 변경자를 호출하는 코드가 앞에서 추가한 추가/제거 함수를 호출하도록 수정한다
5. 컬렉션 getter를 수정해서 원본 내용을 수정할 수 없는 복제본을 반환하게 한다
6. 테스트한다

> **기본형을 객체로 바꾸기 절차**
1. 아직 변수를 캡슐화하지 않았다면 캡슐화한다
2. 단순한 값 클래스를 만들어 생성자는 기존 값을 인수로 받아 저장하고 이 값을 변환하는 getter를 추가한다
3. 테스트한다
4. 값 클래스의 인스턴스를 새로 만들어 필드에 저장하도록 setter를 수정
5. 새로 만든 클래스의 getter를 호출한 결과를 반환하도록 수정
6. 테스트한다
7. 함수 이름을 바꾸면 더 알아보기 쉬워지는지 고려

> **임시변수를 질의 함수로 바꾸기 절차**
1. 변수가 사용되기 전에 값이 확실히 결정되는지 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지는 않는지 확인한다
2. 읽기전용이 가능하면 일기전용으로 만들기
3. 테스트한다
4. 변수 대입문을 함수로 추출
5. 테스트한다
6. 변수 인라인하기로 임시 변수를 제거

> **클래스 추출하기 절차**
1. 클래스의 역할을 분리할 방법을 정한다
2. 분리될 역할을 담당할 클래스를 새로 만든다
3. 원래 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하여 필드에 저장해둔다
4. 분리될 역할에 필요한 필드들을 새 클래스로 옮긴다
    * 옮길때마다 테스트한다
5. 메서드들도 새 클래스로 옮긴다
    * 호출당하는 일이 많은 메서드부터 옮기면서 테스트한다
6. 양쪽 클래스의 인터페이스에서 불필요한 메서드를 제거한다
7. 새 클래스를 외부로 노출할지 정한다
    * 노출 시엔 새 클레스에 참조를 값으로 바꿀지 고려한다


> **클래스 인라인하기 절차**
1. 소스 클래스의 각 public 메서드에 대응하는 메서드들을 타깃 클래스에 생성
    * 이 메서드들은 단순히 작업을 소스 클래스로 위임해야 한다
2. 소스 클래스의 메서드를 사용하는 코드를 모두 타깃 클래스의 위임 메서드를 사용하도록 바꾸고 테스트한다
3. 소스 클래스의 메서드와 필드 모두 타깃 클래스로 옮기고 테스트한다
4. 소스 클래스를 삭제한다

> **위임 숨기기 절차**
1. 위임 객체의 각 메서드에 해당하는 위임 메서드를 서버에 생성한다
2. 클라이언트가 위임 객체 대신 서버를 호출하도록 수정하고 테스트한다
3. 모두 수정하면 서버로부터 위임 객체를 얻는 접근자를 제거한다
4. 테스트한다

> **중개자 제거하기 절차**
1. 위임 객체를 얻는 getter를 생성한다
2. 위임 메서드를 호출하는 클라이언트가 모두 이 getter를 거치도록 수정하고 테스트한다
3. 수정이 끝나면 위임 메서드를 삭제한다

> **알고리즘 교체하기 절차**
1. 교체할 코드를 함수 하나에 모으기
2. 이 함수만을 이용해 동작을 검증하는 테스트를 마련한다
3. 대체할 알고리즘을 준비
4. 테스트한다
5. 기존 알고리즘과 새 알고리즘의 결과를 비교하는 테스트를 수행한다
    * 두 결과가 같을 때 까지 새 알고리즘을 테스트하고 디버깅한다

</details>

## Chapter 08
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/tree/master/Chapter08)

<details markdown="chapter-08">
<summary>챕터 내 자세한 내용 보기</summary>

> **함수 옮기기 절차**
1. 선택한 함수가 현재 컨텍스트에서 사용 중인 모든 요소를 살펴보고 함께 옮겨야 할 함수가 있는지 고려한다
    * 함께 옮겨야 할 함수가 있다면 대체로 그 함수를 먼저 옮기는 게 낫다
    * 하위 함수들의 호출자가 고수준 함수 하나뿐이라면 하위 함수들을 먼저 고수준 함수에 인라인한다
2. 선택한 함수가 다형 메서드인지 확인한다
3. 선택한 함수를 타깃 컨텍스트로 복사하고 타깃 함수를 다듬는다
    * 함수 본문에서 소스 컨텍스트의 요소를 사용한다면 매개변수로 넘겨주거나 소스 컨텍스트 자체를 참조로 넘긴다
4. 테스트한다
5. 소스 컨텍스트에서 타깃 함수를 참조하도록 한다
6. 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다
7. 테스트한다
8. 소스 함수를 인라인할지 고민해본다

> **필드 옮기기 절차**
1. 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다
2. 테스트한다
3. 타깃 객체에 필드와 접근자 메서드들을 생성한다
4. 테스트한다
5. 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다
6. 접근자들이 타깃 필드를 사용하도록 수정한다
7. 테스트한다
8. 소스 필드를 제거한다
9. 테스트한다

> **문장을 함수로 옮기기 절차**
1. 반복 코드가 함수 호출 부분과 멀리 떨어져 있다면 문장 슬라이드하기를 적용해 근처로 옮긴다
2. 타깃 함수를 호출하는 곳이 한 곳뿐이면 단순히 소스 위치에서 해당 코드를 잘라내어 피호출 함수로 복사하고 테스트한다
    * 이 경우라면 나머지 단계는 무시한다
3. 호출자가 둘 이상이면 호출자 중 하나에서 타깃 함수 호출 부분과 옮기려는 문장들을 다른 함수로 추출하고 임시 이름을 지어준다
4. 다른 호출자 모두 방금 추출한 함수를 사용하도록 수정한다
5. 모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인하고 원래 함수를 제거한다
6. 새로운 함수의 이름을 원래 함수 이름으로 변경한다

> **문장을 호출한 곳으로 옮기기 절차**
1. 호출자가 한두개뿐이고 피호출 함수도 간단하다면 피호출 함수의 처음줄을 잘라내서 호출자로 복사해넣는다
    * 테스트가 통과되면 여기서 마무리한다
2. 이동이 필요하지 않은 문장은 함수로 추출하고
3. 원래 함수를 인라인한다
4. 추출된 함수의 이름을 원래 함수의 이름으로 변경한다

> **인라인 코드를 함수 호출로 바꾸기**
* 함수는 여러 동작을 하나로 묶어주는 역할이지만 이미 존재하는 함수와 같은 일을 하는 함수가 더 있다면 해당 코드를 함수 호출로 대체하기

> **문장 슬라이드하기 절차**
1. 코드 조각의 원래 위치와 목표 위치 사이의 코드를 보고 조각을 모으면 동작이 달라질 코드가 있는지 본다
    * 코드 조각에서 참조하는 요소를 선언하는 문장 앞으로는 이동할 수 없다
    * 코드 조각을 참조하는 요소의 뒤로는 이동할 수 없다
    * 코드 조각에서 참조하는 요소를 수정하는 문장을 건너뛰어 이동할 수 없다 
    * 코드 조각이 수정하는 요소를 참조하는 요소를 건너뛰어 이동할 수 없다
2. 코드 조각을 잘라내어 목표 위치에 붙여넣는다
3. 테스트한다

> **반복문 쪼개기 절차**
1. 반복문을 복제해 두 개로 만든다
2. 반복문이 중복되어 생기는 부수효과를 파악해서 제거한다
3. 테스트한다
4. 각 반복문을 함수로 추출할지 고려한다

> **반복문을 파이프라인으로 바꾸기 절차**
1. 반복문에서 사용하는 컬렉션을 가리키는 변수를 만든다
2. 각 단위 행위를 적절한 파이프라인 연산[(*주2)](#주2)으로 대체하고 대체할 때마다 테스트한다
3. 반복문의 모든 동작을 대체했다면 반복문을 삭제한다

> **죽은 코드 제거하기**
* 더 이상 사용되지 않는 코드는 지운다
* 혹시 다시 필요해질것 같다면 버전 관리 시스템에 저장해놓은 버전을 불러와 적용한다

</details>

## Chapter 09
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/tree/master/Chapter09)

<details markdown="chapter-09">
<summary>챕터 내 자세한 내용 보기</summary>

> **변수 쪼개기 절차**
1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다
2. 가능하면 이때 const로 선언한다(JS의 경우)
3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름으로 바꾼다
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다
5. 테스트한다
6. 반복하며 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다

> **필드 이름 바꾸기 절차**
1. 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정하고 테스트한다
2. 레코드가 캡슐화되지 않았다면 우선 캡슐화부터 진행한다
3. 캡슐화된 객체 안의 private 필드명을 변경하고 내부 메서드도 변경한다
4. 테스트한다
5. 생성자의 매개변수 중 필드와 이름이 겹치는 게 있다면 함수 선언 바꾸기로 변경한다
6. 접근자의 이름도 바꿔준다

> **파생 변수를 질의 함수로 바꾸기 절차**
1. 변수 값이 갱신되는 지점을 모두 찾아 필요하다면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다
2. 해당 변수의 값을 계산해주는 함수를 만든다
3. 해당 변수가 사용되는 모든 곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다
4. 테스트한다
5. 변수를 읽는 코드를 모두 함수 호출로 대체한다
6. 테스트한다
7. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다

> **참조를 값으로 바꾸기 절차**
1. 후보 클래스가 불변인지 혹은 불변이 될 수 있는지 확인한다
2. 각각의 setter를 하나씩 제거한다
3. 이 값 객체의 필드들을 사용하는 동치성 비교 메서드를 만든다

> **값을 참조로 바꾸기 절차**
1. 같은 부류에 속하는 객체들을 보관할 저장소를 만든다
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 하고 수정할 때마다 테스트한다

> **매직 리터럴 바꾸기 절차**
1. 상수를 선언하고 매직 리터럴을 대입한다
2. 해당 리터럴이 사용되는 곳을 모두 찾는다
3. 찾은 곳에서 다 같은 의미로 쓰였는지 확인하고 같은 의미라면 대체하고 테스트한다

```
    const STANDARD_GRAVIRTY = 9.81;
    function potentialEnergy(mass, height) {
        // return mass * 9.81 * height;
        return mass * STANDARD_GRAVIRTY * height;
    }
```

</details>

## Chapter 10
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/tree/master/Chapter10)

<details markdown="chapter-10">
<summary>챕터 내 자세한 내용 보기</summary>

> **조건문 분해하기**
* 조건식과 그 조건식에 딸린 조건절 각각을 함수로 추출한다

> **조건식 통합하기 절차**
1. 해당 조건식들 모두에 부수효과가 없는지 확인한다
2. 조건문 두 개를 선택하여 두 조건문의 조건식들을 논리 연산자로 결합한다
3. 테스트한다
4. 조건이 하나만 남을 때 까지 반복한다
5. 하나로 합쳐진 조건식을 함수로 추출할지 고려해본다

> **중첩 조건문을 보호 구문으로 바꾸기 절차**
1. 교체해야 할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 바꾼다
2. 테스트한다
3. 필요하다면 1~2 과정을 반복한다
4. 모든 보호 구문이 같은 결과를 반환한다면 보호 구문들의 조건식을 통합한다

> **조건부 로직을 다형성으로 바꾸기 절차**
1. 다형적 동작을 표현하는 클래스들이 아직 없다면 만들어준다
    * 적합한 인스턴스를 알아서 만들어 반환하는 팩터리 함수도 같이 만든다
2. 호출하는 코드에서 팩터리 함수를 사용하게 한다
3. 조건부 로직 함수를 슈퍼클래스로 옮긴다
4. 서브클래스 중 하나를 선택하여 슈퍼클래스의 조건부 로직 메서드를 오버라이드한다
    * 조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 서브클래스 메서드로 복사하고 적절히 수정한다
5. 같은 방식으로 각 조건절을 해당 서브클래스에서 메서드로 구현한다
6. 슈퍼클래스 메서드에는 기본 동작 부분만 남긴다
    * 슈퍼클래스가 추상 클래스여야 한다면 이 메서드를 추상으로 선언하거나 서브클래스에서 처리해야 함을 알리는 에러를 던진다

> **특이 케이스 추가하기**
1. 컨테이너에 특이 케이스인지를 검사하는 속성을 추가하고 false를 반환하게 한다
2. 특이 케이스 객체를 만들고 특이 케이스인지 검사하는 속성만 포함하여 true를 반환하게 한다
3. 클라이언트에서 특이 케이스인지를 검사하는 코드를 함수로 추출하여 모든 클라이언트가 값을 직접 비교하는 대신 방금 추출한 함수를 사용하도록 고친다
4. 코드에 새로운 특이 케이스 대상을 추가하고 함수의 반환 값으로 받거나 변환 함수를 적용한다
5. 특이 케이스를 검사하는 함수 본문을 수정하여 특이 케이스 객체의 속성을 사용하도록 한다
6. 테스트한다
7. 여러 함수를 클래스로 묶기나 여러 함수를 변환 함수로 묶기를 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮긴다
8. 특이 케이스 검사 함수를 이용하는 곳이 남아있다면 해당 함수를 인라인한다

> **어서션 추가하기**
* **"어서션이 실패했다는 건 프로그래머가 잘못했다는 뜻이다"**
* 참이라고 가정하는 조건이 보이면 그 조건을 명시하는 어서션을 추가하여 디버깅 혹은 다른 개발자와 소통 수단으로 이용하자

> **제어 플래그를 탈출문으로 바꾸기 절차**
1. 제어 플래그를 사용하는 코드를 함수로 추출할지 고려한다
2. 제어 플래그를 갱신하는 코드 각각을 적절한 제어문으로 바꾸고 바꿀 때 마다 테스트한다
3. 모두 수정했다면 제어 플래그를 제거한다

</details>

## Chapter 11
[코드 보기](https://github.com/harrykim14/Refactoring-2nd-Edition/tree/master/Chapter11)
<details markdown="chapter-11">
<summary>챕터 내 자세한 내용 보기</summary>

> **질의 함수와 변경 함수 분리하기 절차**
1. 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다
2. 새 질의 함수에서 부수효과를 모두 제거한다
3. 테스트(정적 검사)한다
4. 원래 함수를 호출하는 곳을 찾아 질의 함수를 호출하도록 바꾸고 원래 함수를 호출하는 코드를 바로 아래 줄에 새로 추가한다
5. 원래 함수에서 질의 관련 코드를 제거한다
6. 테스트한다

> **함수 매개변수화하기 절차**
1. 비슷한 함수 중 하나를 선택한다
2. 함수 선언 바꾸기로 리터럴들을 매개변수로 추가한다
3. 이 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가한다
4. 테스트한다
5. 매개변수로 받은 값을 사용하도록 함수 본문을 수정하고 수정할 때마다 테스트한다
6. 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 수정하고 수정할 때마다 테스트한다

> **플래그 인수 제거하기 절차**
1. 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적 함수들을 생성한다
    * 주가 되는 함수에 깔끔한 분배 조건문이 포함되어 있다면 조건문 분해하기로 명시적 함수를 생성하고 아니라면 래핑 함수 형태로 만든다
2. 원래 함수를 호출하는 코드를 모두 찾아 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정한다

> **객체 통째로 넘기기 절차**
1. 매개변수들을 원하는 형태로 받는 빈 함수를 만든다
2. 새 함수의 본문에서는 원래 함수를 호출하도록 하며 새 매개변수와 원래 함수의 매개변수를 매핑한다
3. 정적 테스트한다
4. 모든 호출자가 새 함수를 사용하게 수정하고 하나씩 수정하며 테스트한다
5. 호출자를 모두 수정했다면 원래 함수를 인라인한다
6. 새 함수의 이름을 수정 후 모든 호출자에 반영한다

> **매개변수를 질의 함수로 바꾸기 절차**
1. 필요하다면 대상 매개변수의 값을 계산하는 코드를 별도 함수로 추출해놓는다
2. 함수 본문에서 대상 매개변수로의 참조를 모두 찾고 그 매개변수의 값을 만들어주는 표현식을 참조하도록 바꾼다
    * 수정할 때마다 테스트한다
3. 함수 선언 바꾸기로 대상 매개변수를 없앤다

> **질의 함수를 매개변수로 바꾸기 절차**
1. 변수 추출하기로 질의 코드를 함수 본문의 나머지 코드와 분리한다
2. 함수 본문 중 해당 질의를 호출하지 않는 코드들을 별도 함수로 추출한다
3. 방금 만든 변수를 인라인하여 제거한다
4. 원래 함수도 인라인한다
5. 새 함수의 이름을 원래 함수의 이름으로 고쳐준다

> **setter 제거하기 절차**
1. 설정해야 할 값을 생성자에서 받지 않는다면 그 값을 받을 매개변수를 생성자에 추가한다
    * 생성자 안에서 적절한 setter를 호출한다
2. 생성자 밖에서 setter를 호출하는 곳을 찾아 제적하고 대신 새로운 생성자를 사용하도록 한다
    * 하나 수정할 때마다 테스트한다
3. setter 메서드를 인라인하고 가능하다면 해당 필드를 불변으로 만든다
4. 테스트한다

> **생성자를 팩터리 함수로 바꾸기 절차**
1. 팩터리 함수를 만들고 팩터리 함수의 본문에서는 원래의 생성자를 호출한다
2. 생성자를 호출하던 코드를 팩터리 함수 호출로 바꾼다
3. 수정할 때마다 테스트한다
4. 생성자의 가시 범위가 최소가 되도록 제한한다

> **함수를 명령어로 바꾸기 절차**
1. 대상 함수의 기능을 옮길 빈 클래스를 함수 이름에 기초하여 만든다
2. 방금 생성한 빈 클래스로 함수를 옮긴다
3. 각 함수의 인수들은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다

> **명령을 함수로 바꾸기 절차**
1. 명령을 생성하는 코드와 명령의 실행 메서드를 호출하는 코드를 함수로 추출한다
2. 명령의 실행 함수가 호출하는 각 보조 메서드를 인라인한다
3. 함수 선언 바꾸기로 생성자의 매개변수 모두를 명령의 실행 메서드로 옮긴다
4. 명령의 실행 메서드에서 참조한느 필드들 대신 대응하는 매개변수를 사용하게끔 바꾸고 테스트한다
5. 생성자 호출과 명령의 실행 메서드 호출을 호출자 안으로 인라인한다
6. 테스트한다
7. 죽은 코드 제거하기로 명령 클래스를 제거한다

> **수정된 값 반환하기 절차**
1. 함수가 수정된 값을 반환하게 하여 호출자가 그 값을 자신의 변수에 저장하게 한다
2. 테스트한다
3. 피호출 함수 안에 반환할 값을 가리키는 새로운 변수를 선언한다
4. 테스트한다
5. 계산이 선언과 동시에 이뤄지도록 통합한다
6. 테스트한다
7. 피호출 함수의 변수 이름을 바꾼다
8. 테스트한다

> **오류 코드를 예외로 바꾸기 절차**
1. 콜스택 상위에 해당 예외를 처리할 예외 핸들러를 작성한다
    * 처음에는 모든 예외를 다시 던지게 한다
    * 이미 핸들러가 있다면 지금의 콜스택도 처리할 수 있도록 확장한다
2. 테스트한다
3. 해당 오류코드를 대체할 예외와 그 밖의 예외를 구분할 식별 방법을 찾는다
4. 정적 검사한다
5. catch절을 수정하여 직접 처리할 수 있는 예외는 대처하고 그 외엔 다시 던진다
6. 테스트한다
7. 오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정하고 테스트한다
8. 모두 수정했다면 그 오류 코드를 콜스택 위로 전달하는 코드를 모두 제거하고 테스트한다

> **예외를 사전확인으로 바꾸기 절차**
1. 예외를 유발하는 상황을 검사할 수 있는 조건문을 추가한다
    * catch 블록의 코드를 조건문의 조건절 중 하나로 옮기고 남은 try 블록의 코드를 다른 조건절로 옮긴다
2. catch 블록에 어서션을 추가하고 테스트한다
3. try/catch문을 제거한다
4. 테스트한다

</details>

<hr/>

#### 주석
* [주1](#chapter-02) : 도착했을때보다 깔끔하게 정돈하고 떠난다(챕터1.7)
* [주2](#chapter-03) : ES6 문법에서 제공하는 filter, reduce, map 등을 활용하는 것
* [주3](#chapter-03) : 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
